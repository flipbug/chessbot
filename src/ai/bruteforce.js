/**
 * Get the next best move by brute force
 * Caution: current implementation is far from efficient.
 *
 * @author Daniel Milenkovic
 */
game.ai.BruteForce = function() {
	/**
	 * The tree is generated by iterating recursively through every move, which is
	 * a quite intensive task, since there are so many possibilities.
	 */
	this.generateGameTree = function(board, turn, currentDepth) {
		var scope = this,
			possibleMoves = [];

		if (board.length > 0 && currentDepth < SIMULATION.DEPTH_LIMIT) {
			// Clone chessboard for simulation, since
			// each evaluation should be independent from the previous one.
			var simBoard = cloneBoard(board);
			var pieces = this.getPiecesOnBoardBySide(simBoard, turn);
			// get possible moves for every piece of current player
			pieces.forEach(function(piece) {
				// iterate through every field to check if possible move
				for (var i = 0; i < simBoard.length; i++) {
					var row = simBoard[i];
					for (var j = 0; j < row.length; j++) {
						var target = new Vector(j, i);
						// check if valid move and generate the following moves
						if (game.core.validator.isValidMove(piece, target, turn, simBoard)) {
							var tempState = scope.simulateMove(piece, target, simBoard);
							var value = tempState.value ? tempState.value : 0;
							var newMove = [
								[piece.x, piece.y],
								[target.x, target.y],
								value
							];

							if (Math.abs(value) < 100000000) {
								newMove[3] = scope.generateGameTree(tempState.board, 1 - turn, currentDepth + 1)
							}

							possibleMoves.push(newMove);
						}
					}
				}
			});
		}

		return possibleMoves;
	};

	this.getPiecesOnBoardBySide = function(board, side) {
		var pieces = [];
		for (var i = 0; i < board.length; i++) {
			var row = board[i];
			for (var j = 0; j < row.length; j++) {
				var piece = row[j];
				if ((side == 0 && piece > 10) || (side == 1 && piece < 10 && piece > 0)) {
					pieces.push(new Vector(j, i));
				}
			}
		}
		return pieces;
	};

	this.simulateMove = function(start, target, board) {
		var simBoard = cloneBoard(board);
		var targetPiece = simBoard[target.y][target.x];
		var value = (target != 0) ? PIECES.VALUES[targetPiece] : 0;

		// update chessboard matrix
		simBoard[target.y][target.x] = simBoard[start.y][start.x];
		simBoard[start.y][start.x] = 0;

		return {
			value: value,
			board: simBoard
		}
	};
};
